//! This crates provides a sequentially locking Ring Buffer. It allows for
//! a fast and non-writer-blocking SPMC queue, where all comsumers read all
//! messages.

use core::mem::MaybeUninit;
use core::sync::atomic::AtomicBool;

pub struct RingBuffer<T: Copy, const N: usize> {
    // what else goes here?
    // version?
    // TODO(Emil): Can we make sure this is properly aligned for cache loads?
    version: usize,
    index: usize,
    locked: AtomicBool,
    data: [Block<T>; N],
}

pub struct WriteGuard<'write, T: Copy, const N: usize> {
    buffer: &'write RingBuffer<T, N>,
}

impl<T: Copy, const N: usize> RingBuffer<T, N> {
    const fn new() -> RingBuffer<T, N> {
        RingBuffer {
            version: 0,
            index: 0,
            locked: false,
            data: [Block::new(); N],
        }
    }

    const fn lock() -> 
}

#[repr(C)]
pub struct Block<T: Copy> {
    seq: usize,
    message: MaybeUninit<T>,
}

impl<T: Copy> Block<T> {
    const fn new() -> Block<T> {
        Block {
            seq: 0,
            message: MaybeUninit::uninit(),
        }
    }
}

impl<T: Copy> Clone for Block<T> {
    fn clone(&self) -> Self {
        Block {
            seq: self.seq,
            message: self.message,
        }
    }
}

impl<T: Copy> Copy for Block<T> {}
